
"""
    compile(m::Mechanism)
    compile(m::VirtualMechanismSystem)

Compile a `Mechanism` or `VirtualMechanismSystem` into an immutable form used for computations.
"""
function compile end


"""
    get_compiled_frameID(m::$_CompiledSystems, c::String)

Returns compiled frame ID of frame with name `c`. This can be used to get the frames's transform,
velocity, jacobian etc. from a kinematics/dynamics cache.
"""
function get_compiled_frameID end

"""
    get_compiled_jointID(m::$_CompiledSystems, c::String)

Returns the compiled joint ID of a joint with name `c`. This can be used to change the joint data
for a compiled system, e.g. when numerically optimizing the robot structure.
"""
function get_compiled_jointID end


"""
    get_compiled_coordID(m::$_CompiledSystems, c::String)

Returns the compiled coordinate ID of a coordinate with name `c`. This can be used to get the 
configuration/velocity/jacobian of a coordinate from a kinematics/dynamics cache.
"""
function get_compiled_coordID end

"""
    get_compiled_componentID(m::$_CompiledSystems, c::String)

Returns the compiled component ID of a component with name `c`. Can be used to mutate the component
data of a compiled mechanism, or recompute information such as the force generated by the component.  
"""
function get_compiled_componentID end

"""
    assemble_state(m::$_CompiledSystems, q, q̇)

Assembles a state vector from a configuration `q` and velocity `q̇`. This is useful for setting up
ODEs for simulation.
"""
function assemble_state end

"""
    zero_q(m::$_CompiledSystems)

Returns a zero configuration for the system. For a mechanism, this is a vector of zeros,
and for a virtual mechanism system, this is a tuple of vectors of zeros (one for the robot,
one for the virtual mechanism).
"""
function zero_q end


"""
    zero_q̇(m::$_CompiledSystems)

Returns a zero velocity for the system. For a mechanism, this is a vector of zeros,
and for a virtual mechanism system, this is a tuple of vectors of zeros (one for the robot,
one for the virtual mechanism).
"""
function zero_q̇ end

"""
    zero_q̈(m::$_CompiledSystems)

Returns a zero acceleration for the system. For a mechanism, this is a vector of zeros,
and for a virtual mechanism system, this is a tuple of vectors of zeros (one for the robot,
one for the virtual mechanism).
"""
function zero_q̈ end

"""
    zero_u(m::$_CompiledSystems)

Returns a zero control input for the system. For a mechanism, this is a vector of zeros,
and for a virtual mechanism system, this is a tuple of vectors of zeros (one for the robot,
one for the virtual mechanism).
"""
function zero_u end


####################################################################################################

"""
    EltypeCache{VALUETYPE, F<:Function}

A cache for storing results of a function with different eltypes. For example, if a Vector{Float64},
and Vector{Float32} cache are both needed, then VALUETYPE can be `Vector{T} where T` and function
can be (VALUETYPE, ELTYPE) -> Vector{ELTYPE}().
"""
struct EltypeCache{F<:Function}
    keys::Vector{UInt}
    values::Vector{Any}
    initializer::F
    function EltypeCache(initializer)
        new{typeof(initializer)}(
            Vector{Int}(),
            Vector{Any}(),
            initializer
        )
    end
end

function Base.getindex(c::EltypeCache{F}, ::Type{ELTYPE}) where {F<:Function, ELTYPE}
    ReturnType = Base.promote_op(c.initializer, Type{ELTYPE})
    if ~isconcretetype(ReturnType)
        c.initializer(ELTYPE)
        # @code_warntype c.initializer(ELTYPE)
        error("Must infer concrete return type for initializer function $(c.initializer) on $(typeof(ELTYPE)) $ELTYPE. Got $ReturnType.")
    end
    key = objectid(ELTYPE)::UInt
    for i in eachindex(c.keys)
        if c.keys[i] === key
            ret = c.values[i]
            return ret::ReturnType
        end
    end
    # Otherwise, create cache
    value = c.initializer(ELTYPE)::ReturnType
    push!(c.keys, key)
    push!(c.values, value)
    return value::ReturnType
end

Base.show(io::IO, c::EltypeCache) = print(io, "EltypeCache{...} with keys $(c.keys) and values $(c.values)")
Base.show(io::IO, ::Type{<:EltypeCache}) = print(io, "EltypeCache{...}")

########################
# Compile coordinates
########################

function __construct_coordinate_graph(coordinates, ID_map, skip_if)
    graph = SimpleDiGraph()
    add_vertices!(graph, length(coordinates))
    foreach(coordinates) do (src_id, coord)
        foreach(dependencies(coord)) do dependency_id
            skip_if(dependency_id) && (return nothing)
            add_edge!(graph, ID_map[dependency_id], ID_map[src_id])
        end
        nothing
    end
    graph
end

"""
    _construct_coordinate_graph(coordinates)

Construct a graph of coordinates dependencies on each other.
"""
function _construct_coordinate_graph(coordinates; skip_if=id->false)
    ID_map = Dict(id => i  for (i, id) in enumerate(keys(coordinates)))
    unique_ids = unique(values(ID_map))
    length(coordinates) == length(unique_ids) || throw(ErrorException("Multiple coordinates with the same ID. Coordinate IDs: $(collect(c.id for c in coordinates))"))
    __construct_coordinate_graph(coordinates, ID_map, skip_if), ID_map
end

function determine_coordinate_computation_order(coord_graph, ID_to_vertex_map, coordinates; is_computed=id->false)
    vertex_to_ID_map = Dict(i=>id for (id, i) in ID_to_vertex_map)        
    vertex_computation_order = try
        # Check that the graph is a tree
        topological_sort(coord_graph)
    catch e
        error("Cannot topologically sort coordinates. This is probably because of a circular dependency in the coordinates.")
    end
    depth = ones(Int, length(vertex_computation_order))
    for vert in vertex_computation_order        
        id = vertex_to_ID_map[vert]
        coord = coordinates[id]
        for dep_id in dependencies(coord)
            is_computed(dep_id) && continue # Skip if we are told that this coord is already computed
            dep_vert = ID_to_vertex_map[dep_id]
            depth[vert] = max(depth[vert], depth[dep_vert] + 1)
        end
    end
    # Now we must create a vector-of-vectors. Each inner vector is a set of coordinates that 
    # can be computed simulatenously, and the outer vector is the order in which to compute them. 
    coord_id_computation_order = [Vector{String}() for i in 1:maximum(depth; init=0)]
    for (vert, d) in enumerate(depth)
        push!(coord_id_computation_order[d], vertex_to_ID_map[vert])
    end
    coord_id_computation_order
end

function _promote_vec_of_typestable_collections_to_common_type(v::Vector{TypeStableCollection})
    if isempty(v)
        return TypeStableCollection{Tuple{}}[]
    end
    # Get all unique coordinate types
    all_eltypes = Type[]
    for tsc in v
        for T in eltype.(tsc.tup)
            push!(all_eltypes, T)
        end
        unique!(all_eltypes)
    end
    # Extend each tsc to have all types
    for i in eachindex(v)
        for type in all_eltypes
            v[i] = extend_type(v[i], type)
        end
    end
    # Combine into type stable return vector
    ret = Vector{typeof(v[1])}()
    for tsc in v
        push!(ret, tsc) # Will error if types don't match. 
    end
    ret
end

function compile_coordinates_in_order(coord_id_computation_order, coordinates)
    compiled_coords = TypeStableCollection[TypeStableCollection() for i in 1:length(coord_id_computation_order)]
    coord_id_map = Dict{String, CompiledCoordID}()
    coord_cache_idx = 1
    for (depth, coord_ids) in enumerate(coord_id_computation_order)
        coord_data = getindex.((coordinates,), coord_ids)
    
        # Now we must replace any references to Coord ID strings with compiled coord IDs. We must do 
        # this in order starting with leafs, which do not depend on any other coordinates, so are trivial
        # to replace.        
        for (i, (id, coord_data_raw)) in enumerate(zip(coord_ids, coord_data))
            coord_data_compiled = _reassign_coords(coord_data_raw, coord_id_map)
            Nc = cache_size(coord_data_compiled)
            compiled_coord = CompiledCoord(coord_data_compiled, coord_cache_idx:coord_cache_idx+Nc-1)
            coord_cache_idx += Nc
            compiled_coords[depth], idx = extend(compiled_coords[depth], compiled_coord)
            coord_id_map[id] = CompiledCoordID(depth, idx)
        end
    end
    # Finally promote all tscs to same type
    compiled_coords_out = _promote_vec_of_typestable_collections_to_common_type(compiled_coords)
    coord_id_map, compiled_coords_out
end

function compile_coordinates(
        coordinates_in::Dict{String, <:CoordinateData}, 
        frame_id_map::AbstractDict, 
        joint_id_map::AbstractDict
    )
    coordinates = let 
        tmp = Dict{String, CoordinateData}(id => reassign_frames(cd, frame_id_map) 
                                           for (id, cd) in coordinates_in)
        Dict{String, CoordinateData}(id => reassign_joints(cd, joint_id_map) 
                                           for (id, cd) in tmp)
    end
    
    coord_graph, ID_to_vertex_map = _construct_coordinate_graph(coordinates)
    coord_id_computation_order = determine_coordinate_computation_order(coord_graph, ID_to_vertex_map, coordinates)
    compile_coordinates_in_order(coord_id_computation_order, coordinates)
end

#######################
# RBTree
#######################

function determine_root_frame(starting_frame, joints_reassigned)
    # Asssumes that the joint tree is a tree.
    root_frame = starting_frame
    stop = false
    while ~stop
        stop = true
        for (_jointID, mjoint) in joints_reassigned
            (;parentFrameID, childFrameID) = mjoint
            if childFrameID == root_frame
                root_frame = parentFrameID
                stop = false
            end
        end
    end
    root_frame
end

"""
    RBTree(m:Mechanism)

Fundamental data structure behind efficient kinematics computations. Used to 
store caches for computations, and information about compiled frames/joints/coordinates

Strategy:
- There are a few things to do when going from a `Mechanism` to an `CompiledMechanism`. 
  The first is to change all frames from being referenced by strings to being referenced 
  by indexes (of type Int). This is done using the `reassign_frames` function for 
  coordinates/components and in the constructor for joints.

- The second is to change references to joints from strings of the joints name to a
  suitable alternative, like a compiled joint ID, as the size of the joint-configuration vector 
  q must be able to be determined by the type of the ID in order to know it's size at compile time.
  This is done using the `reassign_joints`

- The next is to create a type stable way to compute the extended kinematics (transforms, 
  twists and velocity product accelerations of each frame), and the jacobians of each frame. 
  This is accomplished by building a type-agnostic cache for each, and creating a `Walk` of 
  the rigid body tree.  The walk is simply a concrete order in which to compute and apply 
  joint transformation. For example, the tree with frames (1, 2, 3, 4), and structure:
    1 -> 2 -> 3
     \\-> 4    
  Could have a walk [(1, 2), (2, 3), (1, 4)], or equivalently [(1, 2), (1, 4), (2, 3)], or 
  [(1, 4), (1, 2), (2, 3)]. The important fact is that a transform earlier in the tree is 
  always computed before a transform later in the tree.

- Each different joint type requires different methods, we create a `joint_collection` 
  which has a field for each different joint type. This allows us to use 
  `map` or `foreach` to efficiently dispatch to joints to compute relative 
  transforms/twists/vpas, and then we use the walk to accumulate the effect of each.
  This works because despite each joint being a different type, the output of `map`
  or `foreach` is a the same.

- For coordinates, a different approach is needed to store the dependency order. First we
  determine a suitable `TypeStableCollection` type for the collection of all coordinates, 
  then we create a directed graph of dependencies between coordinates. We then topologically
  sort the graph to determine the order in which to compute the coordinates. This is done
  by first computing the depth of each coordinate, and then creating a vector of vectors 
  where each inner vector is a set of coordinates that can be computed simultaneously, as
  they do not depend on each other.
"""
struct RBTree{T, JC<:TypeStableCollection, CC<:TypeStableCollection}
    ndof::Int
    walk::Vector{Tuple{Int, Int}} # Walks the tree from root to leaves
    joint_collection::JC
    coordinates::Vector{CC}
    frameancestors::Matrix{Bool}
    descendants::Vector{Vector{Int}}
    frame_id_map::Dict{String, CompiledFrameID}
    joint_id_map::OrderedDict{String, CompiledJointID}
    coord_id_map::Dict{String, CompiledCoordID}
    function RBTree(m::Mechanism{T}) where T
        # Things to compute once
        N_frames = length(frames(m))
        mgraph = MechanismGraph(m)

        if !is_connected(mgraph)
            connected_frames = getindex.( (frames(m), ), weakly_connected_components(mgraph))
            error("Robot graph is not connected. There are $(length(connected_frames)) connected sets of frames. These are $connected_frames.")
        end
        if is_cyclic(mgraph)
            cycles = getindex.( (frames(m), ), cycle_basis(mgraph))
            throw(ErrorException("Robot graph is cyclic, expected a tree. Cycles are: $cycles."))
        end
        # Convert to non-directed graph to check if it is a tree
        is_tree(SimpleGraph(mgraph)) || throw(ErrorException("Robot is not a tree..."))
         

        
        # TODO Handle closed loop kinematics by splitting non-tree graphs into 
        # a set of trees with missing joints. Replace those joints by 
        # constraints in the constraint-coordinates of the missing joint.
        # Do so automatically? Allow the reversing of joint direction
        # (parent→child / child→parent)?

        # Assign frame IDs
        frame_id_map = Dict(frame=>CompiledFrameID(i) for (frame, i) = zip(frames(m), 1:N_frames))
        joints_reassigned = OrderedDict(key => reassign_frames(mjoint, frame_id_map) for (key, mjoint) in joints(m))

        # Assign joint IDs, and idxs of q, q̇
        compiled_joints_dict = OrderedDict{String, CompiledMechanismJoint}()
        mechanism_config_size = mechanism_velocity_size = 0
        for (jointID, mjoint) in joints_reassigned
            q_idx, q̇_idx = mechanism_config_size + 1, mechanism_velocity_size + 1
            compiled_joints_dict[jointID] = CompiledMechanismJoint(
                mjoint.jointData, 
                mjoint.parentFrameID, 
                mjoint.childFrameID, 
                q_idx, 
                q̇_idx
            )
            mechanism_config_size += config_size(mjoint)
            mechanism_velocity_size += velocity_size(mjoint)
        end
    
        joint_id_map = OrderedDict{String, CompiledJointID}()
        joint_collection = TypeStableCollection()
        for (jointID, compiled_joint) in compiled_joints_dict
            joint_collection, jc_idx = extend(joint_collection, compiled_joint)
            joint_id_map[jointID] = CompiledJointID(jc_idx)
        end

        coord_id_map, compiled_coords::Vector{<:TypeStableCollection} = compile_coordinates(coordinates(m), frame_id_map, joint_id_map)

        # Now, by traversing the graph of joints, create an ordered list of 
        # child/parent frame IDs as integers, starting with root frame 1.
        walk = Vector{Tuple{Int, Int}}()
        # Determine root frame by climbing up the tree
        _root_frame = determine_root_frame(frames(m)[1], joints(m))
        (_root_frame != root_frame(m)) && @warn("True frame ($_root_frame) is not the first frame ($(root_frame(m))). Consider redefining mechanism so that the first frame is called \"root_frame\".")
        
        # Traverse joint/frame graph
        current_frames = [frame_id_map[_root_frame]]::Vector{CompiledFrameID}
        while !isempty(current_frames)
            # Get all joints which have 'frame' as their parent
            frame = pop!(current_frames)
            for (; parentFrameID, childFrameID) in values(joints_reassigned)
                if parentFrameID == frame
                    push!(current_frames, childFrameID)
                    push!(walk, (parentFrameID.idx, childFrameID.idx))
                end
            end
        end
        @assert length(walk) == N_frames - 1 "Unexpected error. Walk must have length $(N_frames - 1), got $(length(walk)). The graph's (undirected) structure is a tree, therefore the direction of one of the joints must be incorrect."

        N = ndof(m)
        frameancestors = frame_ancestor_matrix(mgraph)
        # Similar to the walk, descendants[frame] is a list of all frames which are distal of `frame``
        # including itself
        descendants = [
            collect(i for i in 1:N_frames if (frameancestors[frame, i] || i == frame))
            for frame in 1:N_frames
        ]

        JC = typeof(joint_collection)
        CC = eltype(compiled_coords)
        new{T, JC, CC}(
            N, walk, joint_collection, compiled_coords, frameancestors, descendants,
            frame_id_map, joint_id_map, coord_id_map)
    end
end

# get_joint_from_id(r::RBTree, id) = r.walk[r.jointmap[id]]

Base.iterate(r::RBTree) = iterate(r.walk)
Base.iterate(r::RBTree, i::Integer) = iterate(r.walk, i)

# @inline Base.getindex(r::RBTree, i::Real) = (@boundscheck checkbounds(r,i); r.walk[to_index(i)])
Base.@propagate_inbounds Base.getindex(r::RBTree, i) = r.walk[i]
Base.lastindex(r::RBTree) = lastindex(r.walk)

Base.eltype(::Type{<:RBTree{T, JC}} ) where {T, JC} = T
Base.eltype(::R) where R<:RBTree = eltype(R)

num_frames(rbtree::RBTree) = length(rbtree.walk) + 1
num_steps(::RBTree) = length(rbtree.walk)
ndof(rbtree::RBTree) = rbtree.ndof

##########################
# Compiled Mechanism
##########################

function _compile_component!(
        cc::TypeStableCollection, 
        id::String, 
        component_data::ComponentData, 
        ret_component_id_map::Dict, 
        frame_id_map::AbstractDict, 
        joint_id_map::AbstractDict, 
        coord_id_map::AbstractDict
    )
    GC = startswith(id, "Grav")
    cd1 = reassign_frames(component_data,   frame_id_map)
    cd2 = reassign_joints(cd1,              joint_id_map)
    cd3 = reassign_coords(cd2,              coord_id_map)
    cc, idx = extend(cc, cd3)
    ret_component_id_map[id] = CompiledComponentID(idx)
    cc
end

function _compile_components!(component_dict, args...)
    component_collection = TypeStableCollection()
    for (component_id, component_data) in component_dict
        component_collection = _compile_component!(component_collection, component_id, component_data , args...)
    end
    component_collection
end

"""
    CompiledMechanism(m::Mechanism)

A compiled version of a `Mechanism` which is used for efficient kinematics/dynamics computations.

See also: [`compile`](@ref), [`Mechanism`](@ref)
"""
struct CompiledMechanism{T, R, CC}
    name::String
    rbtree::R
    components::CC
    component_id_map::Dict{String, CompiledComponentID}
    function CompiledMechanism(m::Mechanism{T}) where T
        rbtree = RBTree(m)
        component_id_map = Dict{String, CompiledComponentID}() 
        _components = _compile_components!(
            components(m), 
            component_id_map, 
            rbtree.frame_id_map, 
            rbtree.joint_id_map, 
            rbtree.coord_id_map
        )
        new{T, typeof(rbtree), typeof(_components)}(name(m), rbtree, _components, component_id_map)
    end
end

Base.show(io::IO, m::CompiledMechanism) = print(io, "CompiledMechanism{$(eltype(m))...}($(name(m)))")
Base.show(io::IO, ::Type{CompiledMechanism{T, R, CC}}) where {T, R, CC} = print(io, "CompiledMechanism{$T, $R, $CC}")

name(m::CompiledMechanism) = m.name
frames(m::CompiledMechanism) = collect(keys(m.rbtree.frame_id_map))
num_frames(m::CompiledMechanism) = num_frames(m.rbtree)
joints(m::CompiledMechanism) = m.rbtree.joint_collection
coordinates(m::CompiledMechanism) = m.rbtree.coordinates
components(m::CompiledMechanism) = m.components
Base.eltype(::Type{<:CompiledMechanism{T, R, CC}}) where {T, R, CC} = T
Base.eltype(m::CompiledMechanism) = eltype(typeof(m))

@inline config_size(m::CompiledMechanism) = ndof(m.rbtree) # TODO generalize to allow different config/velocity sizes
@inline velocity_size(m::CompiledMechanism) = ndof(m.rbtree) # TODO generalize to allow different config/velocity sizes
@inline ndof(m::CompiledMechanism) = ndof(m.rbtree)

inertances(m::CompiledMechanism) = filtertype(m.components, Inertance)
storages(m::CompiledMechanism) = filtertype(m.components, Storage)
dissipations(m::CompiledMechanism) = filtertype(m.components, Dissipation)
generic_components(m::CompiledMechanism) = filtertype(m.components, GenericComponent)
visuals(m::CompiledMechanism) = filtertype(m.components, Visual)


compile(m::Mechanism) = CompiledMechanism(m)

q_idxs(m::CompiledMechanism) = 1:config_size(m)
q̇_idxs(m::CompiledMechanism) = config_size(m)+1: config_size(m)+velocity_size(m)

state_idxs(m::CompiledMechanism) = q_idxs(m), q̇_idxs(m)
function assemble_state(m::CompiledMechanism, q::Vector{T}, q̇::Vector{T}) where T
    x0 = zeros(eltype(q), length(q) + length(q̇))
    q_idxs, q̇_idxs = state_idxs(m)
    @assert length(q_idxs) == length(q) "q must have length $(length(q_idxs))"
    @assert length(q̇_idxs) == length(q̇) "q̇ must have length $(length(q̇_idxs))"
    x0[q_idxs] .= q
    x0[q̇_idxs] .= q̇
    x0
end

get_compiled_frameID(m::CompiledMechanism, c::String) = get_compiled_frameID(m.rbtree.frame_id_map, c)
get_compiled_jointID(m::CompiledMechanism, c::String) = get_compiled_joint(m.rbtree.joint_id_map, c)
get_compiled_coordID(m::CompiledMechanism, c::String) = get_compiled_coordID(m.rbtree.coord_id_map, c)
get_compiled_componentID(m::CompiledMechanism, c::String) = m.component_id_map[c]

get_compiled_joint(m::CompiledMechanism, jointID::CompiledJointID) = joints(m)[jointID.idx]
get_compiled_coord(m::CompiledMechanism, coordID::CompiledCoordID) = coordinates(m)[coordID]
get_compiled_component(m::CompiledMechanism, componentID::CompiledComponentID) = components(m)[componentID]

Base.getindex(m::CompiledMechanism, id::CompiledJointID) = get_compiled_joint(m, id)
Base.getindex(m::CompiledMechanism, id::CompiledCoordID) = get_compiled_coord(m, id)
Base.getindex(m::CompiledMechanism, id::CompiledComponentID) = get_compiled_component(m, id)

Base.setindex!(m::CompiledMechanism, val::J, id::CompiledJointID{J}) where J = joints(m)[id.idx] = val
Base.setindex!(m::CompiledMechanism, val::C, id::CompiledCoordID{C}) where C = coordinates(m)[id.idx] = val
Base.setindex!(m::CompiledMechanism, val::C, id::CompiledComponentID{C}) where C = components(m)[id.idx] = val

get_force_components(m::CompiledMechanism) = filtertype(components(m), Union{Storage, Dissipation, Inertance, GenericComponent})
get_inertance_components(m::CompiledMechanism) = filtertype(components(m), Union{Inertance, GenericComponent})
get_energy_components(m::CompiledMechanism) = filtertype(components(m), Union{Storage, Inertance, GenericComponent})
